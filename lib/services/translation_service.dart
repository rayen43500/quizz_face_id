import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import 'package:google_mlkit_translation/google_mlkit_translation.dart';

/// Service de traduction utilisant Google ML Kit pour la traduction hors ligne
class TranslationService {
  // Mod√®les de traduction
  final Map<String, OnDeviceTranslator> _translators = {};
  final Map<String, bool> _downloadedModels = {
    'en_fr': false,
    'en_ar': false,
    'fr_en': false,
    'ar_en': false,
  };
  
  // Files d'attente pour les t√©l√©chargements de mod√®les
  final Map<String, Completer<bool>> _downloadCompleters = {};

  // Langues support√©es par le service
  final List<String> _supportedLanguages = ['en', 'fr', 'ar'];
  bool _isInitialized = false;
  bool _isNativePluginAvailable = true;
  
  // Statistiques de performance
  int _totalTranslations = 0;
  int _cacheHits = 0;
  int _translationErrors = 0;
  
  // Cache LRU (Least Recently Used) pour les traductions
  final int _maxCacheSize = 1000;
  final LinkedHashMap<String, String> _translationCache = LinkedHashMap();
  
  // Singleton pattern
  static final TranslationService _instance = TranslationService._internal();
  
  factory TranslationService() {
    return _instance;
  }
  
  TranslationService._internal() {
    // D√©sactiver ML Kit sur le web car il n'est pas support√©
    if (kIsWeb) {
      debugPrint('‚ö†Ô∏è Ex√©cution sur le web d√©tect√©e, ML Kit sera d√©sactiv√©');
      _isNativePluginAvailable = false;
    }
  }

  /// Initialiser le service de traduction
  Future<bool> initialize() async {
    if (_isInitialized) return true;

    // Si on est sur le web, on utilise directement le mode fallback
    if (kIsWeb) {
      debugPrint('‚ö†Ô∏è ML Kit n\'est pas support√© sur le web, utilisation du mode fallback');
      _isNativePluginAvailable = false;
      _isInitialized = true;
      return true;
    }

    try {
      debugPrint('üåê Initialisation du service de traduction ML Kit...');
      // Cr√©ation des traducteurs pour chaque paire de langues
      await _createTranslators();
      _isInitialized = true;
      debugPrint('‚úÖ Service de traduction ML Kit initialis√© avec succ√®s');
      return true;
    } catch (e) {
      debugPrint('‚ùå Erreur lors de l\'initialisation du service de traduction: $e');
      
      // Si l'erreur est li√©e √† l'absence du plugin natif, d√©sactiver ML Kit
      if (e.toString().contains('MissingPluginException')) {
        debugPrint('‚ö†Ô∏è Plugin ML Kit non disponible sur cette plateforme, utilisation du mode fallback');
        _isNativePluginAvailable = false;
        _isInitialized = true; // On consid√®re quand m√™me le service comme initialis√©
        return true;
      }
      
      // R√©essayer l'initialisation apr√®s un d√©lai
      await Future.delayed(const Duration(seconds: 2));
      return false;
    }
  }

  /// Cr√©er les traducteurs pour toutes les paires de langues support√©es
  Future<void> _createTranslators() async {
    if (!_isNativePluginAvailable) {
      debugPrint('‚ö†Ô∏è Plugin ML Kit non disponible, traducteurs non cr√©√©s');
      return;
    }
    
    for (final sourceLanguage in _supportedLanguages) {
      for (final targetLanguage in _supportedLanguages) {
        if (sourceLanguage != targetLanguage) {
          final key = '${sourceLanguage}_$targetLanguage';
          
          try {
            final sourceLanguageCode = _getTranslateLanguage(sourceLanguage);
            final targetLanguageCode = _getTranslateLanguage(targetLanguage);

            final translator = OnDeviceTranslator(
              sourceLanguage: sourceLanguageCode,
              targetLanguage: targetLanguageCode,
            );

            _translators[key] = translator;
            debugPrint('üìö Traducteur cr√©√©: $sourceLanguage -> $targetLanguage');

            // V√©rifier si le mod√®le est d√©j√† t√©l√©charg√©
            await _checkModelDownloadStatus(sourceLanguage, targetLanguage);
          } catch (e) {
            debugPrint('‚ö†Ô∏è Erreur lors de la cr√©ation du traducteur $key: $e');
            
            if (e.toString().contains('MissingPluginException')) {
              _isNativePluginAvailable = false;
              debugPrint('‚ö†Ô∏è Plugin ML Kit non disponible, arr√™t de la cr√©ation des traducteurs');
              return;
            }
          }
        }
      }
    }
  }

  /// V√©rifier si un mod√®le de langue est d√©j√† t√©l√©charg√©
  Future<bool> _checkModelDownloadStatus(String sourceLanguage, String targetLanguage) async {
    if (!_isNativePluginAvailable) return false;
    
    final key = '${sourceLanguage}_$targetLanguage';
    
    try {
      final targetLanguageCode = _getTranslateLanguage(targetLanguage);
      final modelManager = OnDeviceTranslatorModelManager();
      
      final isDownloaded = await modelManager.isModelDownloaded(
        targetLanguageCode.bcpCode,
      );
      
      _downloadedModels[key] = isDownloaded;
      
      if (isDownloaded) {
        debugPrint('üì• Mod√®le d√©j√† t√©l√©charg√©: $sourceLanguage -> $targetLanguage');
      } else {
        debugPrint('üì§ Mod√®le non t√©l√©charg√©: $sourceLanguage -> $targetLanguage');
      }
      
      return isDownloaded;
    } catch (e) {
      debugPrint('‚ö†Ô∏è Erreur lors de la v√©rification du mod√®le $key: $e');
      
      if (e.toString().contains('MissingPluginException')) {
        _isNativePluginAvailable = false;
      }
      
      return false;
    }
  }

  /// Convertir le code de langue interne en TranslateLanguage compatible avec ML Kit
  TranslateLanguage _getTranslateLanguage(String language) {
    switch (language) {
      case 'en':
        return TranslateLanguage.english;
      case 'fr':
        return TranslateLanguage.french;
      case 'ar':
        return TranslateLanguage.arabic;
      default:
        debugPrint('‚ö†Ô∏è Langue non support√©e: $language, utilisation de l\'anglais par d√©faut');
        return TranslateLanguage.english;
    }
  }

  /// T√©l√©charger le mod√®le de traduction si n√©cessaire
  /// Retourne true si le mod√®le est disponible (d√©j√† t√©l√©charg√© ou t√©l√©chargement r√©ussi)
  Future<bool> downloadModelIfNeeded(String sourceLanguage, String targetLanguage) async {
    // Si le plugin natif n'est pas disponible, on ne peut pas t√©l√©charger de mod√®les
    if (!_isNativePluginAvailable) return false;
    
    // V√©rifier que les deux langues sont support√©es
    if (!_supportedLanguages.contains(sourceLanguage) ||
        !_supportedLanguages.contains(targetLanguage)) {
      debugPrint('‚ùå Paire de langues non support√©e: $sourceLanguage -> $targetLanguage');
      return false;
    }

    final key = '${sourceLanguage}_$targetLanguage';
    
    // Si le mod√®le est d√©j√† t√©l√©charg√©, retourner imm√©diatement
    if (_downloadedModels[key] == true) {
      return true;
    }
    
    // Si un t√©l√©chargement est d√©j√† en cours pour ce mod√®le, attendre sa fin
    if (_downloadCompleters.containsKey(key)) {
      debugPrint('‚è≥ T√©l√©chargement d√©j√† en cours pour $key, attente...');
      return await _downloadCompleters[key]!.future;
    }
    
    // Cr√©er un nouveau completer pour ce t√©l√©chargement
    _downloadCompleters[key] = Completer<bool>();
    
    try {
      debugPrint('üì• T√©l√©chargement du mod√®le: $sourceLanguage -> $targetLanguage');

      final targetLanguageCode = _getTranslateLanguage(targetLanguage);
      final modelManager = OnDeviceTranslatorModelManager();

      // T√©l√©charger le mod√®le avec options avanc√©es
      await modelManager.downloadModel(
        targetLanguageCode.bcpCode,
        isWifiRequired: false,  // Permettre le t√©l√©chargement sur donn√©es mobiles
      );

      _downloadedModels[key] = true;
      debugPrint('‚úÖ Mod√®le t√©l√©charg√© avec succ√®s: $sourceLanguage -> $targetLanguage');
      
      // Compl√©ter le future avec succ√®s
      _downloadCompleters[key]!.complete(true);
      return true;
    } catch (e) {
      debugPrint('‚ùå Erreur lors du t√©l√©chargement du mod√®le $key: $e');
      
      if (e.toString().contains('MissingPluginException')) {
        _isNativePluginAvailable = false;
      }
      
      // Compl√©ter le future avec √©chec
      _downloadCompleters[key]!.complete(false);
      return false;
    } finally {
      // Nettoyer le completer apr√®s utilisation
      _downloadCompleters.remove(key);
    }
  }

  /// Traduire du texte entre les langues support√©es
  Future<String> translateText(String text, String sourceLanguage, String targetLanguage) async {
    _totalTranslations++;
    
    // Cas triviaux: texte vide ou m√™me langue source/cible
    if (text.isEmpty) return text;
    if (sourceLanguage == targetLanguage) return text;

    // V√©rifier que les deux langues sont support√©es
    if (!_supportedLanguages.contains(sourceLanguage) ||
        !_supportedLanguages.contains(targetLanguage)) {
      debugPrint('‚ùå Paire de langues non support√©e: $sourceLanguage -> $targetLanguage');
      return text;
    }

    // Cl√© de cache unique pour cette traduction
    final cacheKey = '$text|$sourceLanguage|$targetLanguage';

    // V√©rifier si la traduction est d√©j√† dans le cache
    if (_translationCache.containsKey(cacheKey)) {
      // Mettre √† jour l'ordre LRU en supprimant et r√©ins√©rant la cl√©
      final cachedValue = _translationCache.remove(cacheKey)!;
      _translationCache[cacheKey] = cachedValue;
      
      _cacheHits++;
      return cachedValue;
    }
    
    // Si le plugin natif n'est pas disponible, utiliser une traduction de secours
    if (!_isNativePluginAvailable) {
      return _fallbackTranslation(text, sourceLanguage, targetLanguage);
    }

    try {
      // S'assurer que le service est initialis√©
      if (!_isInitialized) {
        final initialized = await initialize();
        if (!initialized) {
          debugPrint('‚ùå Service de traduction non initialis√©');
          return text;
        }
      }
      
      // S'assurer que le mod√®le est t√©l√©charg√©
      final modelAvailable = await downloadModelIfNeeded(sourceLanguage, targetLanguage);
      if (!modelAvailable) {
        debugPrint('‚ùå Mod√®le de traduction non disponible: $sourceLanguage -> $targetLanguage');
        return _fallbackTranslation(text, sourceLanguage, targetLanguage);
      }

      final key = '${sourceLanguage}_$targetLanguage';
      final translator = _translators[key];

      if (translator == null) {
        debugPrint('‚ùå Traducteur non trouv√©: $sourceLanguage -> $targetLanguage');
        return _fallbackTranslation(text, sourceLanguage, targetLanguage);
      }

      // Effectuer la traduction avec mesure du temps
      final stopwatch = Stopwatch()..start();
      final translatedText = await translator.translateText(text);
      stopwatch.stop();
      
      debugPrint('‚úÖ Traduction effectu√©e en ${stopwatch.elapsedMilliseconds}ms: $sourceLanguage -> $targetLanguage');

      // G√©rer le cache LRU: supprimer l'√©l√©ment le plus ancien si le cache est plein
      if (_translationCache.length >= _maxCacheSize) {
        _translationCache.remove(_translationCache.keys.first);
      }
      
      // Mettre en cache la traduction
      _translationCache[cacheKey] = translatedText;

      return translatedText;
    } catch (e) {
      _translationErrors++;
      debugPrint('‚ùå Erreur de traduction: $e');
      
      // En cas d'erreur avec le plugin natif, d√©sactiver ML Kit et utiliser la traduction de secours
      if (e.toString().contains('MissingPluginException')) {
        _isNativePluginAvailable = false;
      }
      
      return _fallbackTranslation(text, sourceLanguage, targetLanguage);
    }
  }
  
  /// M√©thode de traduction de secours quand ML Kit n'est pas disponible
  String _fallbackTranslation(String text, String sourceLanguage, String targetLanguage) {
    debugPrint('‚ö†Ô∏è Utilisation de la traduction de secours pour: $sourceLanguage -> $targetLanguage');
    
    // Dictionnaire de traductions simples pour les cas courants
    final Map<String, Map<String, String>> basicTranslations = {
      'fr': {
        'Question': 'Question',
        'True': 'Vrai',
        'False': 'Faux',
        'Next': 'Suivant',
        'Back': 'Retour',
        'Time left': 'Temps restant',
        'seconds': 'secondes',
        'easy': 'facile',
        'medium': 'moyen',
        'hard': 'difficile',
        'Entertainment: Music': 'Divertissement: Musique',
        'Entertainment: Film': 'Divertissement: Cin√©ma',
        'Entertainment: Television': 'Divertissement: T√©l√©vision',
        'Entertainment: Video Games': 'Divertissement: Jeux Vid√©o',
        'Science & Nature': 'Science & Nature',
        'Sports': 'Sports',
        'Geography': 'G√©ographie',
        'History': 'Histoire',
        'Politics': 'Politique',
        'Art': 'Art',
      },
      'ar': {
        'Question': 'ÿ≥ÿ§ÿßŸÑ',
        'True': 'ÿµÿ≠Ÿäÿ≠',
        'False': 'ÿÆÿ∑ÿ£',
        'Next': 'ÿßŸÑÿ™ÿßŸÑŸä',
        'Back': 'ÿ±ÿ¨Ÿàÿπ',
        'Time left': 'ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä',
        'seconds': 'ÿ´ŸàÿßŸÜ',
        'easy': 'ÿ≥ŸáŸÑ',
        'medium': 'ŸÖÿ™Ÿàÿ≥ÿ∑',
        'hard': 'ÿµÿπÿ®',
        'Entertainment: Music': 'ÿßŸÑÿ™ÿ±ŸÅŸäŸá: ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ',
        'Entertainment: Film': 'ÿßŸÑÿ™ÿ±ŸÅŸäŸá: ÿßŸÑÿ£ŸÅŸÑÿßŸÖ',
        'Entertainment: Television': 'ÿßŸÑÿ™ÿ±ŸÅŸäŸá: ÿßŸÑÿ™ŸÑŸÅÿ≤ŸäŸàŸÜ',
        'Entertainment: Video Games': 'ÿßŸÑÿ™ÿ±ŸÅŸäŸá: ÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÅŸäÿØŸäŸà',
        'Science & Nature': 'ÿßŸÑÿπŸÑŸàŸÖ ŸàÿßŸÑÿ∑ÿ®Ÿäÿπÿ©',
        'Sports': 'ÿßŸÑÿ±Ÿäÿßÿ∂ÿ©',
        'Geography': 'ÿßŸÑÿ¨ÿ∫ÿ±ÿßŸÅŸäÿß',
        'History': 'ÿßŸÑÿ™ÿßÿ±ŸäÿÆ',
        'Politics': 'ÿßŸÑÿ≥Ÿäÿßÿ≥ÿ©',
        'Art': 'ÿßŸÑŸÅŸÜ',
      }
    };
    
    // Si la langue cible est support√©e dans notre dictionnaire de secours
    if (basicTranslations.containsKey(targetLanguage)) {
      final translations = basicTranslations[targetLanguage]!;
      
      // Rechercher des correspondances exactes
      if (translations.containsKey(text)) {
        return translations[text]!;
      }
      
      // Rechercher des correspondances partielles
      for (final entry in translations.entries) {
        if (text.contains(entry.key)) {
          return text.replaceAll(entry.key, entry.value);
        }
      }
    }
    
    // Si aucune traduction n'est trouv√©e, retourner le texte original
    return text;
  }
  
  /// Pr√©charger les mod√®les de traduction pour une utilisation future
  Future<void> preloadTranslationModels() async {
    if (!_isNativePluginAvailable) {
      debugPrint('‚ö†Ô∏è Plugin ML Kit non disponible, pr√©chargement des mod√®les annul√©');
      return;
    }
    
    if (!_isInitialized) {
      await initialize();
    }
    
    debugPrint('üîÑ Pr√©chargement des mod√®les de traduction...');
    
    // T√©l√©charger tous les mod√®les en parall√®le
    final futures = <Future<bool>>[];
    
    for (final sourceLanguage in _supportedLanguages) {
      for (final targetLanguage in _supportedLanguages) {
        if (sourceLanguage != targetLanguage) {
          futures.add(downloadModelIfNeeded(sourceLanguage, targetLanguage));
        }
      }
    }
    
    // Attendre que tous les t√©l√©chargements soient termin√©s
    final results = await Future.wait(futures);
    final successCount = results.where((result) => result).length;
    
    debugPrint('‚úÖ Pr√©chargement termin√©: $successCount/${futures.length} mod√®les charg√©s');
  }
  
  /// Vider le cache de traduction
  void clearCache() {
    final cacheSize = _translationCache.length;
    _translationCache.clear();
    debugPrint('üßπ Cache de traduction vid√© ($cacheSize entr√©es)');
  }
  
  /// Obtenir les statistiques de performance du service de traduction
  Map<String, dynamic> getStatistics() {
    final cacheHitRate = _totalTranslations > 0 
        ? (_cacheHits / _totalTranslations * 100).toStringAsFixed(1) 
        : '0';
        
    final errorRate = _totalTranslations > 0 
        ? (_translationErrors / _totalTranslations * 100).toStringAsFixed(1) 
        : '0';
        
    return {
      'totalTranslations': _totalTranslations,
      'cacheHits': _cacheHits,
      'cacheSize': _translationCache.length,
      'cacheHitRate': '$cacheHitRate%',
      'translationErrors': _translationErrors,
      'errorRate': '$errorRate%',
      'supportedLanguages': _supportedLanguages,
      'downloadedModels': Map.from(_downloadedModels),
      'isNativePluginAvailable': _isNativePluginAvailable,
    };
  }

  /// Nettoyer les ressources
  void dispose() {
    debugPrint('üßπ Nettoyage des ressources du service de traduction');
    
    if (_isNativePluginAvailable) {
      for (final translator in _translators.values) {
        translator.close();
      }
    }
    
    _translators.clear();
    _translationCache.clear();
    _downloadCompleters.clear();
    _isInitialized = false;
    
    debugPrint('‚úÖ Service de traduction ferm√©');
  }
}
